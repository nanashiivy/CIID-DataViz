<!DOCTYPE html>
<meta charset="utf-8">
<style>

</style>
<body>
<script type="text/javascript" src="https://d3js.org/d3.v3.min.js"></script>
<script type="text/javascript">


var width = 2880;
var height = 1800;

var lastYear = [];
var incomeGroup = [];
var changeP = [];
var treeData;
var pMin;
var pMax;

var colors = ["#6CD7C6", "#6CDAA9", "#6BDE8A", "#6BE16A", "#8DE569", "#B2E968", "#D9EC67", "#F0DC66", "#F3B664", "#F78E63", "#FA6261"];


d3.csv("data/Forest_Land_SqM_Test.csv", function(myData){
  console.log(myData);
  

    treeData = myData;
    
    for (var i = 0; i<treeData.length; i++) {
        lastYear.push(parseInt(myData[i][2015]));
    }

    for (var i = 0; i<treeData.length; i++) {
        incomeGroup.push(myData[i].IncomeGroup);
    }

    for (var i = 0; i<treeData.length; i++) {
        changeP.push(parseFloat(myData[i]["% of change"]));
    }

    console.log(changeP + "CHANGE");

    var min = d3.min(lastYear);
    var max = d3.max(lastYear);



    pMin = d3.min(changeP);
    pMax = d3.max(changeP);

    console.log("Min: " + pMin);
    console.log("Max: " + pMax);

    var rScale = d3.scale.linear() 
                .domain([min, max])//what is the min and max coming in
                .range([5, 200])//whati is the min and max comimg out

    var nodes = d3.range(lastYear.length).map(function(d,i) { 

        return {
            // radius: lastYear[i] / 10000
            radius : rScale(lastYear[i])
            }
        }),
        root = nodes[0];
        // color = d3.scale.category10();

    // var radius = d3.scaleLinear()
    // .domain([0, data.length])//what is the min and max coming in
    // .range([10, width-10])//whati is the min and max comimg out
    
    root.radius = 0;
    root.fixed = true;


    // var force = d3.layout.force()
    //     .gravity(0.05)
    //     .charge(function(d, i) { return i ? 0 : -2000; })
    //     .nodes(nodes)
    //     .size([width, height]);

    // force.start();

    var xCoordinates = d3.scale.ordinal([250, 500, 750, 1000]);

    var incomeGroupEnum = ["Low income","Lower middle income","Upper middle income","High income"];
    var incomeGroupEnumValues = [250, 500, 750, 1000];

    var rScale = d3.scale.linear() 
        .domain([min, max])//what is the min and max coming in
        .range([5, 100])//whati is the min and max comimg out
    
    var yScale = d3.scale.linear() 
        .domain([pMin, pMax])//what is the min and max coming in
        .range([400, 1000])//whati is the min and max comimg out

    var colorScale = d3.scale.quantize()
        .domain([pMax,pMin])
        .range(colors);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
            svg.selectAll("circle")
        .data(myData)
        .enter().append("circle")
        .attr("r", function(d) { 
          // console.log(d["2015"]);
          return rScale(+d["2015"]); 
        })
        .attr("cx", function(d) { 
          return incomeGroupEnumValues[incomeGroupEnum.indexOf(d.IncomeGroup)] } )
        // .attr("cy", height/2)
        .attr("cy", function(d) { 
          // console.log(d["2015"]);
          return yScale(parseFloat(d["% of change"])); 
        })

        .style("fill", function(d,i){
          return colorScale(parseFloat(d["% of change"]));
        })
        .style("stroke","grey")
        .style("opacity", 0.5);

    


    // force.on("tick", function(e) {
    //   var q = d3.geom.quadtree(nodes),
    //       i = 0,
    //       n = nodes.length;

    //   while (++i < n) q.visit(collide(nodes[i]));

    //   svg.selectAll("circle")
    //       .attr("cx", function(d) { return d.x; })
    //       .attr("cy", function(d) { return d.y; });
    // });

    // function collide(node) {
    //   var r = node.radius + 16,
    //       nx1 = node.x - r,
    //       nx2 = node.x + r,
    //       ny1 = node.y - r,
    //       ny2 = node.y + r;
    //   return function(quad, x1, y1, x2, y2) {
    //     if (quad.point && (quad.point !== node)) {
    //       var x = node.x - quad.point.x,
    //           y = node.y - quad.point.y,
    //           l = Math.sqrt(x * x + y * y),
    //           r = node.radius + quad.point.radius;
    //       if (l < r) {
    //         l = (l - r) / l * .5;
    //         node.x -= x *= l;
    //         node.y -= y *= l;
    //         quad.point.x += x;
    //         quad.point.y += y;
    //       }
    //     }
    //     return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    //   };
    // }




})

</script>

</body>
</html>